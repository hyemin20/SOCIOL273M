ggplot2::scale_shape_manual(values = shapes) +
ggplot2::scale_size_manual(values = size) +
ggplot2::scale_discrete_manual(aesthetics = "stroke", values = stroke) +
ggplot2::scale_color_manual(values = colors) +
ggplot2::labs(y = NULL, x = wrap(xlab, wrap))
class(lp) <- c(class(lp), "love.plot")
plot.list[[s]] <- lp
}
# If just one stat (and use.grid not TRUE), return plot
if (length(stats) == 1 && !isTRUE(args$use.grid)) {
p <- plot.list[[1]] +
ggplot2::labs(title = title, subtitle = subtitle) +
ggplot2::theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = position)
if (is_not_null(themes[[1]])) {
p <- p + themes[[1]]
}
return(p)
}
# Combine plots together
position <- {
if (!chk::vld_string(position)) NA_character_
else match_arg(position,
c("right", "left", "top", "bottom", "none"))
}
#Process labels
if (isTRUE(labels)) labels <- LETTERS[seq_along(plot.list)]
else if (is_null(labels) || isFALSE(labels)) labels <- NULL
else if (!is.atomic(labels) || length(labels) != length(plot.list)) {
.wrn("`labels` must be `TRUE` or a string with the same length as `stats`. Ignoring `labels`")
labels <- NULL
}
else labels <- as.character(labels)
plots.to.combine <- plot.list
for (i in seq_along(plots.to.combine)) {
plots.to.combine[[i]] <- {
if (i > 1) {
plots.to.combine[[i]] +
ggplot2::theme(axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
legend.position = "none")
}
else {
plots.to.combine[[i]] + ggplot2::theme(legend.position = "none")
}
}
if (is_not_null(labels)) {
plots.to.combine[[i]] <- plots.to.combine[[i]] + ggplot2::labs(title = labels[i])
}
if (is_not_null(themes[[stats[i]]])) {
plots.to.combine[[i]] <- plots.to.combine[[i]] + themes[[stats[i]]]
}
}
g <- ggarrange_simple(plots = plots.to.combine, nrow = 1)
title.grob <- grid::textGrob(title, gp = grid::gpar(fontsize = 13.2))
subtitle.grob <- grid::textGrob(subtitle, gp = grid::gpar(fontsize = 13.2))
if (position == "none") {
p <- gridExtra::arrangeGrob(grobs = list(g), nrow = 1)
}
else {
legend.to.get <- {
if (all(get_from_STATS("adj_only")[stats])) 1
else which(!get_from_STATS("adj_only")[stats])[1]
}
legg <- ggplot2::ggplotGrob(plots.to.combine[[legend.to.get]] + ggplot2::theme(legend.position = position))
if (any(legg$layout$name == "guide-box")) {
leg <- legg$grobs[[which(legg$layout$name == "guide-box")]]
}
else if (any(legg$layout$name == paste0("guide-box-", position))) {
# ggplot2 >=3.5.0 can have multiple legends
leg <- legg$grobs[[which(legg$layout$name == paste0("guide-box-", position))]]
}
else {
position <- "none"
}
p <- {
if (position == "left")
gridExtra::arrangeGrob(grobs = list(leg, g), nrow = 1,
widths = grid::unit.c(sum(leg$widths),
grid::unit(1, "npc") - sum(leg$widths)))
else if (position == "right")
gridExtra::arrangeGrob(grobs = list(g, leg), nrow = 1,
widths = grid::unit.c(grid::unit(1, "npc") - sum(leg$widths),
sum(leg$widths)))
else if (position == "top")
gridExtra::arrangeGrob(grobs = list(leg, g), nrow = 2,
heights = grid::unit.c(sum(leg$heights),
grid::unit(1, "npc") - sum(leg$heights)))
else if (position == "bottom")
gridExtra::arrangeGrob(grobs = list(g, leg), nrow = 2,
heights = grid::unit.c(grid::unit(1, "npc") - sum(leg$heights),
sum(leg$heights)))
}
}
if (is_not_null(subtitle)) {
p <- gridExtra::arrangeGrob(p, top = subtitle.grob)
}
p <- gridExtra::arrangeGrob(p, top = title.grob)
grid::grid.newpage()
grid::grid.draw(p)
attr(p, "plots") <- plot.list
class(p) <- c(class(p), "love.plot")
invisible(p)
}
#' @exportS3Method autoplot bal.tab
autoplot.bal.tab <- function(object, ...) {
love.plot(object, ...)
}
#' @exportS3Method plot bal.tab
plot.bal.tab <- function(x, ...) {
love.plot(x, ...)
}
# Helper functions
isColor <- function(x) {
tryCatch(is.matrix(grDevices::col2rgb(x)),
error = function(e) FALSE)
}
f.recode <- function(f, ...) {
#Simplified version of forcats::fct_recode
f <- factor(f)
new_levels <- unlist(list(...), use.names = TRUE)
old_levels <- levels(f)
idx <- match(new_levels, old_levels)
old_levels[idx] <- names(new_levels)
levels(f) <- old_levels
f
}
seq_int_cycle <- function(begin, end, max) {
seq(begin, end, by = 1) - max * (seq(begin - 1, end - 1, by = 1) %/% max)
}
assign.shapes <- function(colors, default.shape = "circle") {
if (nunique(colors) < length(colors)) {
seq_int_cycle(19, 19 + length(colors) - 1, max = 25)
}
else {
rep.int(default.shape, length(colors))
}
}
shapes.ok <- function(shapes, nshapes) {
shape_names <- c(
"circle", paste("circle", c("open", "filled", "cross", "plus", "small")), "bullet",
"square", paste("square", c("open", "filled", "cross", "plus", "triangle")),
"diamond", paste("diamond", c("open", "filled", "plus")),
"triangle", paste("triangle", c("open", "filled", "square")),
paste("triangle down", c("open", "filled")),
"plus", "cross", "asterisk"
)
shape_nums <- 1:25
(length(shapes) == 1 || length(shapes) == nshapes) &&
((is.numeric(shapes) && all(shapes %in% shape_nums)) ||
(is.character(shapes) && all(shapes %in% shape_names)))
}
gg_color_hue <- function(n) {
hues <- seq(15, 375, length = n + 1)
grDevices::hcl(h = hues, l = 65, c = 100)[seq_len(n)]
}
ggarrange_simple <- function(plots, nrow = NULL, ncol = NULL) {
#A thin version of egg:ggarrange
gtable_frame <- function (g, width = grid::unit(1, "null"), height = grid::unit(1, "null")) {
panels <- g[["layout"]][grepl("panel", g[["layout"]][["name"]]),]
pargins <- g[["layout"]][grepl("panel", g[["layout"]][["name"]]),]
ll <- unique(panels$l)
margins <- if (length(ll) == 1) grid::unit(0, "pt") else g$widths[ll[-length(ll)] + 2]
tt <- unique(panels$t)
fixed_ar <- g$respect
if (fixed_ar) {
ar <- as.numeric(g$heights[tt[1]])/as.numeric(g$widths[ll[1]])
height <- width * (ar/length(ll))
g$respect <- FALSE
}
core <- g[seq(min(tt), max(tt)), seq(min(ll), max(ll))]
top <- g[seq(1, min(tt) - 1), seq(min(ll), max(ll))]
bottom <- g[seq(max(tt) + 1, nrow(g)), seq(min(ll), max(ll))]
left <- g[seq(min(tt), max(tt)), seq(1, min(ll) - 1)]
right <- g[seq(min(tt), max(tt)), seq(max(ll) + 1, ncol(g))]
fg <- grid::nullGrob()
if (is_not_null(left)) {
lg <- gtable::gtable_add_cols(left, grid::unit(1, "null"), 0)
lg <- gtable::gtable_add_grob(lg, fg, 1, l = 1)
}
else {
lg <- fg
}
if (is_not_null(right)) {
rg <- gtable::gtable_add_cols(right, grid::unit(1, "null"))
rg <- gtable::gtable_add_grob(rg, fg, 1, l = ncol(rg))
}
else {
rg <- fg
}
if (is_not_null(top)) {
tg <- gtable::gtable_add_rows(top, grid::unit(1, "null"), 0)
tg <- gtable::gtable_add_grob(tg, fg, t = 1, l = 1)
}
else {
tg <- fg
}
if (is_not_null(bottom)) {
bg <- gtable::gtable_add_rows(bottom, grid::unit(1, "null"),
-1)
bg <- gtable::gtable_add_grob(bg, fg, t = nrow(bg), l = 1)
}
else {
bg <- fg
}
grobs <- list(fg, tg, fg, lg, core, rg, fg, bg, fg)
widths <- grid::unit.c(sum(left$widths), width, sum(right$widths))
heights <- grid::unit.c(sum(top$heights), height, sum(bottom$heights))
all <- gtable::gtable_matrix("all", grobs = matrix(grobs, ncol = 3, nrow = 3, byrow = TRUE),
widths = widths, heights = heights)
all[["layout"]][5, "name"] <- "panel"
if (fixed_ar)
all$respect <- TRUE
all
}
n <- length(plots)
grobs <- lapply(plots, ggplot2::ggplotGrob)
if (is_null(nrow) && is_null(ncol)) {
nm <- grDevices::n2mfrow(n)
nrow <- nm[1]
ncol <- nm[2]
}
hw <- lapply(rep(1, n), grid::unit, "null")
fg <- lapply(seq_along(plots), function(i) gtable_frame(g = grobs[[i]],
width = hw[[i]], height = hw[[i]]))
spl <- split(fg, rep(1, n))
rows <- lapply(spl, function(r) do.call(gridExtra::gtable_cbind, r))
gt <- do.call(gridExtra::gtable_rbind, rows)
invisible(gt)
}
bal.tab_class_sequence <- function(b) {
if (inherits(b, "bal.tab.bin") || inherits(b, "bal.tab.cont")) return(NULL)
b_ <- b[[which(endsWith(names(b), ".Balance"))]][[1]]
c(class(b)[1], bal.tab_class_sequence(b_))
}
unpack_bal.tab <- function(b) {
unpack_bal.tab_internal <- function(b) {
if (inherits(b, "bal.tab.bin") || inherits(b, "bal.tab.cont")) return(b[["Balance"]])
b_ <- b[[which(endsWith(names(b), ".Balance"))]]
b_list <- lapply(b_, function(i) {
if (inherits(b, "bal.tab.bin") || inherits(b, "bal.tab.cont")) return(i[["Balance"]])
unpack_bal.tab_internal(i)
})
b_list
}
LinearizeNestedList <- function(NList, NameSep) {
# LinearizeNestedList:
#
# https://sites.google.com/site/akhilsbehl/geekspace/
#         articles/r/linearize_nested_lists_in_r
#
# Akhil S Bhel
#
if (is.data.frame(NList)) return(NList)
A <- 1
B <- length(NList)
while (A <= B) {
Element <- NList[[A]]
EName <- names(NList)[A]
if (is.list(Element)) {
Before <- {
if (A == 1) NULL
else NList[1:(A - 1)]
}
After <- {
if (A == B) NULL
else NList[(A + 1):B]
}
if (is.data.frame(Element)) {
Jump <- 1
}
else {
NList[[A]] <- NULL
Element <- LinearizeNestedList(Element, NameSep)
names(Element) <- paste(EName, names(Element), sep = NameSep)
Jump <- length(Element)
NList <- c(Before, Element, After)
}
}
else {
Jump <- 1
}
A <- A + Jump
B <- length(NList)
}
NList
}
namesep <- paste(c("|", unlist(lapply(1:20, function(i) sample(LETTERS, 1))), "|"), collapse = "")
out_ <- unpack_bal.tab_internal(b)
out <- LinearizeNestedList(out_, NameSep = namesep)
attr(out, "namesep") <- namesep
attr(out, "class_sequence") <- bal.tab_class_sequence(b)
out
}
### Call function
list.files(file.path(work_dir, "functions"), full.names = TRUE) %>% walk(source)
### Call libraries
library(tidyverse); library(MatchIt); library(ggplot2); library(optmatch); library(cobalt); library(gridExtra)
### Call libraries
library(tidyverse); library(MatchIt); library(ggplot2); library(optmatch); library(cobalt); library(gridExtra)
### Call function
list.files(file.path(work_dir, "functions"), full.names = TRUE) %>% walk(source)
love.plot(match_ps, thresholds = c(m = .1), var.order = "unadjusted")
love.plot(match_ps)
love.plot(w.out1, stats = "m", threshold = .1,
var.order = "unadjusted", var.names = v)
love.plot(match_ps, stats = "m", threshold = .1,
var.order = "unadjusted", var.names = v)
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
}
list[1]
ggplot(list[1])
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
p[i] <- list[[i]]
}
p <- ()
p <- ()
p <- c()
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
p[i] <- list[[i]]
}
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
paste(p, [i]) <- list[[i]]
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
paste(p, i) <- list[[i]]
}
paste(p, i)
p = NULL
# 10 random covariate balance plots (hint try gridExtra)
set.seed(123)
list <- list()
paste(p, i)
paste(p + i)
paste("p"+i)
paste("p", i)
paste("p",i)
paste0("p",i)
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
paste0("p",i) <- list[[i]]
}
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
paste0("p",i) <- list[i]
}
for (i in 1:10) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(replace = TRUE,
formula = ps_formula,
data = ypsps_clean,
method = "nearest",
ratio = 1,
estimand = "ATT")
list[[i]] <- bal.plot(model_ps)
}
list[1]
list[2]
for (i in 1:10) {
paste0("p",i) <- list[i]
}
p1 <- list[1]; p2 <- list[2]; p3 <- list[3]
options(repr.plot.width = 12, repr.plot.height = 8)
library(ggplot2)
p1 <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p2 <- ggplot(mtcars, aes(hp, wt)) + geom_point()
p3 <- ggplot(mtcars, aes(drat, wt)) + geom_point()
p1 <- list[1]; p2 <- list[2]; p3 <- list[3]; p4 <- list[4]
p5 <- list[5]; p6 <- list[6]; p7 <- list[7]; p8 <- list[8]
options(repr.plot.width = 12, repr.plot.height = 8)
library(ggplot2)
p1 <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p2 <- ggplot(mtcars, aes(hp, wt)) + geom_point()
p3 <- ggplot(mtcars, aes(drat, wt)) + geom_point()
p4 <- ggplot(mtcars, aes(qsec, wt)) + geom_point()
p5 <- ggplot(mtcars, aes(vs, wt)) + geom_point()
p6 <- ggplot(mtcars, aes(am, wt)) + geom_point()
p7 <- ggplot(mtcars, aes(gear, wt)) + geom_point()
p8 <- ggplot(mtcars, aes(carb, wt)) + geom_point()
# grid.arrange를 사용하여 8개의 그래프를 4x2 격자로 나타내기
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol = 2)
# grid.arrange를 사용하여 8개의 그래프를 4x2 격자로 나타내기
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol = 4)
#
hist(sim_results$percent_imp)
hist(sim_results_r$percent_imp)
```{r warning=FALSE}
# Remove post-treatment covariates
ATTs_r <- c()
prop_balanced_r <- c()
percent_imp_r <- c()
# Randomly select features
# Simulate random selection of features 10k+ times
for (i in 1:1000) {
# Randomly select number of columns
num_cols <- sample(3:ncol(ypsps_clean)-2, 1)
colnames <- sample(names(ypsps_clean %>% select(-c(student_ppnscal, college))), num_cols)
independent <- paste(colnames, collapse = " + ")
ps_formula <- as.formula(paste("college ~", independent))
# Fit p-score models and save ATTs
model_ps <- matchit(formula = ps_formula,
data = ypsps_clean,
distance = "randomforest",
method = "nearest",
ratio = 1)
lm_att <- lm(student_ppnscal ~ college + student_Gen + student_Trust + student_GovtOpinion +
parent_EducHH + parent_Money + parent_Race + parent_GovtOpinion,
data = match.data(model_ps),
weights = weights)
summ <- bal.tab(model_ps, threshold = .1)
att_ps <- lm_att$coefficients['college']
ATTs_r[i] <- att_ps
A <- summ[[1]] %>% select(Diff.Adj) %>% slice(2:n()) %>% pull
prop_balanced_r[i] <- sum(abs(A) <= 0.1) / length(A)
pre <- data.frame(summary(model_ps)$sum.all) %>% pull(Std..Mean.Diff.) %>% mean ()
post <- data.frame(summary(model_ps)$sum.matched) %>% pull(Std..Mean.Diff.) %>% mean ()
percent_imp_r[i] <- (post - pre) / pre
}
